{"ast":null,"code":"import React from'react';import'katex/dist/katex.min.css';import{InlineMath,BlockMath}from'react-katex';/*\n        <h3>\n          Private Aggregation of Teacher Ensembles\n        </h3>\n        <p>\n          Private Aggregation of Teacher Ensembles or PATE is an alternative method to DPSGD for conducting differentially private learning. The key idea is to, rather than train a single strong model which captures a complex criterion in a differentially private manner, train a set of weaker, non-private models on partitions of the data and then perform a noisy aggregation of their predictions. Overall the method has been shown to be quite effective at the expense of some assumptions about the training procedure. There has even been an application of this technique to GANs via PATE-GAN.\n        </p>\n\n        <h3>\n          Differentially Private Federated Learning\n        </h3>\n\n        <h3>\n          Proper Development\n        </h3>\n        <p>\n          There are a number of common gotchas involved with the proper development and deployment of differentially private deep learning models.\n        </p>\n        <p>\n          The biggest is hyperparameter search and model selection. You might think intuitively that, as long as you implement and execute something like DP-SGD, you can sleep soundly at night knowing your model is privacy preserving. Although, typically many models are trained in the process of during the hyperparameter . Although in theory, the hyperparameters you{\"\\'\"}re selecting are technically data-inspired, and hence indirectly leak information. Frankly this detail is swept under the rug in research contexts. But in industry, this absolutely needs to be taken into consideration, or at the very least consciously acknowledged as a risk.\n        </p>\n        <p>\n          The second is proper evaluation. It does not suffice to simply train a single model and report its accuracy. Recall that\n        </p>\n*/function Post(){return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"h2\",null,\"A Guide to Differentially Private Deep Learning\"),/*#__PURE__*/React.createElement(\"p\",null,\"In this post we tackle the topic of privacy-preserving deep learning. This commentary will be less so concerned with precision and proof, and moreso geared towards convincing a deep learning practitioner what privacy should mean, why its important, and how it can be achieved.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Differential Privacy\"),/*#__PURE__*/React.createElement(\"p\",null,\"Before talking about anything else, we need to define what privacy is. There\",\"\\'\",\"s a near infinite continuum of what privacy \",/*#__PURE__*/React.createElement(\"em\",null,\"could\"),\" mean, and naturally some definitions are less vacuous than others.\"),/*#__PURE__*/React.createElement(\"p\",null,\"One such definition is \",/*#__PURE__*/React.createElement(\"em\",null,\"differential privacy\"),\". Differential privacy is concerned with \",/*#__PURE__*/React.createElement(\"em\",null,\"algorithms\"),\", namely functions responsible for mapping a given dataset to some output space, e.g., linear regression mapping a dataset to its coefficients \",/*#__PURE__*/React.createElement(InlineMath,{math:\"w\"}),\" and \",/*#__PURE__*/React.createElement(InlineMath,{math:\"b\"}),\".\"),/*#__PURE__*/React.createElement(\"p\",null,\"On a high level, such an algorithm would \\\"preserve privacy\\\" under the notion of differential privacy if it were to behave (approximately) the same regardless of whether you removed any individual point from the dataset. If you could achieve this property, then you \",/*#__PURE__*/React.createElement(\"em\",null,\"should\"),\" be convinced that this algorithm is privacy-preserving.\"),/*#__PURE__*/React.createElement(\"p\",null,\"Why? Well, let\",\"\\'\",\"s consider how you would feel if one of these points actually corresponded to you. By the definition put forth, you wouldn\",\"\\'\",\"t have grounds to care whether your data is given to the algorithm - the outcome will be the same regardless. In other words, \",/*#__PURE__*/React.createElement(\"em\",null,\"you should feel like this algorithm preserves your privacy because its outputs look the same whether or not your data is given to it\"),\". This is the core idea.\"),/*#__PURE__*/React.createElement(\"p\",null,\"Formally, we can express this notion via the following\",/*#__PURE__*/React.createElement(\"sup\",null,/*#__PURE__*/React.createElement(\"a\",{href:\"https://stephentu.github.io/writeups/6885-lec20-b.pdf\"},\"1\")),\":\"),/*#__PURE__*/React.createElement(\"p\",null,/*#__PURE__*/React.createElement(\"em\",null,\"Let \",/*#__PURE__*/React.createElement(InlineMath,{math:\"A : \\\\mathcal{D} \\\\rightarrow \\\\mathcal{Y}\"}),\" be a randomized algorithm. We call \",/*#__PURE__*/React.createElement(InlineMath,{math:\"A\"}),\" \\\"\",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\varepsilon\"}),\"-differentially private\\\" if for all \",/*#__PURE__*/React.createElement(InlineMath,{math:\"D_1, D_2 \\\\in \\\\mathcal{D}\"}),\" differing in exactly one entry, and for all outputs \",/*#__PURE__*/React.createElement(InlineMath,{math:\"y \\\\in \\\\mathcal{Y}\"}),\", we have that:\",/*#__PURE__*/React.createElement(BlockMath,{math:\"e^{-\\\\varepsilon} \\\\leq \\\\frac{\\\\Pr[\\\\mathcal{A(D_1) = y}]}{\\\\Pr[\\\\mathcal{A(D_2) = y}]} \\\\leq e^\\\\varepsilon\"}))),/*#__PURE__*/React.createElement(\"p\",null,\"Upon inspection, you\",\"\\'\",\"ll notice that this is saying exactly what we established earlier. Namely, the probability of a particular outcome occuring is about the same whether or not you include any particular individual in the dataset.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Deep Learning\"),/*#__PURE__*/React.createElement(\"p\",null,\"It goes without saying that deep learning has become an extremely popular form of statistical analysis. And conveniently, the algorithms of concern in the context of deep learning align perfect with the interface prescribed by differential privacy, namely in mapping provided datasets to some output space, in this context the model parameters.\"),/*#__PURE__*/React.createElement(\"p\",null,\"One of the most pervasive approaches to this is the process of stochastic gradient descent. When conducting stochastic gradient descent, we iteratively update the parameters of a model by repeatedly sampling data and taking small steps over the parameters in the direction which minimizes our loss function. In other words, we repeatedly follow something resembling the following steps:\"),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\{ x^{(1)}, x^{(1)}, \\\\ldots x^{(b)} \\\\} \\\\sim sample(X, b)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\ell(\\\\theta) = \\\\frac{1}{b} \\\\sum_i \\\\ell(x^{(i)} ; \\\\theta)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\theta \\\\leftarrow \\\\theta - \\\\eta \\\\nabla_\\\\theta \\\\ell(\\\\theta)\"}),/*#__PURE__*/React.createElement(\"p\",null,\"It then begs the question as to how one would have to augment this procedure to achieve differential privacy, if at all possible.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Differentially Private Stochastic Gradient Descent\"),/*#__PURE__*/React.createElement(\"p\",null,/*#__PURE__*/React.createElement(\"a\",{href:\"https://arxiv.org/abs/1607.00133\"},\"Abadi et al.\"),\" detail the differentially private stochastic gradient descent (DP-SGD) algorithm to make traditional SGD yield a differential privacy guarantee. To describe it, we need to introduce a number of augmentations.\"),/*#__PURE__*/React.createElement(\"p\",null,\"First, we have to augment our typical method for sampling. In the context of non-private deep learning, sampling is often achieved by shuffling the dataset and running through partitions of size \",/*#__PURE__*/React.createElement(InlineMath,{math:\"b\"}),\" such that each example is viewed by the model exactly once per epoch. Although in the context of DP-SGD, we must opt for either Poisson\",/*#__PURE__*/React.createElement(\"sup\",null,\"2\"),\" or uniform\",/*#__PURE__*/React.createElement(\"sup\",null,\"3\"),\" subsampling if we want to retain an actual differential privacy guarantee.\"),/*#__PURE__*/React.createElement(\"p\",null,\"Second, we need to augment the gradient calculatoin. In particular, we need to introduce a clipping parameter \",/*#__PURE__*/React.createElement(InlineMath,{math:\"C\"}),\", an upper bound on the \",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\ell_2\"}),\"-norm of each per-example gradient, as well as the noise multiplier \",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\sigma\"}),\", which scales the variance of the Gaussian noise applied to each gradient update after clipping. All of this together, we execute the following augmented training loop:\"),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\{ x^{(1)}, x^{(1)}, \\\\ldots x^{(b)} \\\\} \\\\sim sample(X, b)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"g^{(i)} \\\\leftarrow \\\\nabla_{\\\\theta} \\\\ell(x^{(i)} ; \\\\theta)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\bar{g}^{(i)} \\\\leftarrow g^{(i)} / \\\\max\\\\{ 1, ||g^{(i)}||_2 / C\\\\}\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\tilde{g} \\\\leftarrow \\\\frac{1}{b} (\\\\sum_i \\\\bar{g}^{(i)} + \\\\sigma \\\\cdot C \\\\cdot \\\\mathcal{N}(0, I))\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\theta \\\\leftarrow \\\\theta - \\\\eta \\\\tilde{g}\"}),/*#__PURE__*/React.createElement(\"p\",null,\"In order to calculate the privacy loss corresponding to \",/*#__PURE__*/React.createElement(InlineMath,{math:\"t\"}),\" executions of the above update rule, Abadi et al. also details the \",/*#__PURE__*/React.createElement(\"em\",null,\"moments accountant\"),\", a specialized analysis capable of reporting the privacy loss over time. A full deep dive into tools used in the moments accountant is beyond the scope of this post, but it can be understood as simply a black box which takes in your training loop parameters (\",/*#__PURE__*/React.createElement(InlineMath,{math:\"C\"}),\", \",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\sigma\"}),\", \",/*#__PURE__*/React.createElement(InlineMath,{math:\"t\"}),\", etc.) and gives you \",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\varepsilon\"}),\". If interested in learning more, there exists a corresponding implementation within Tensorflow Privacy.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Conlusion\"),/*#__PURE__*/React.createElement(\"p\",null,\"Hopefully this was a useful tutorial outlining differential privacy and its applications to deep learning in plain English. If you have any questions or have caught any errors, feel free to reach out!\"));}export default Post;","map":{"version":3,"sources":["/Users/chriswaites/Documents/projects/ChrisWaites.github.io/src/posts/differentially-private-deep-learning.js"],"names":["React","InlineMath","BlockMath","Post"],"mappings":"AAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAO,0BAAP,CACA,OAASC,UAAT,CAAqBC,SAArB,KAAsC,aAAtC,CAEA;;;;;;;;;;;;;;;;;;;;;;;;EA2BA,QAASC,CAAAA,IAAT,EAAgB,CACZ,mBACE,qDACE,gFADF,cAIE,oTAJF,cAQE,qDARF,cAWE,4GAC+E,IAD/E,6DACgI,sCADhI,uEAXF,cAcE,oEACyB,qDADzB,0DAC+F,2CAD/F,gKACiQ,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EADjQ,sBAC6R,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EAD7R,KAdF,cAiBE,wTAC2Q,uCAD3Q,4DAjBF,cAoBE,8CACiB,IADjB,8HACiJ,IADjJ,+IACoR,qKADpR,4BApBF,cAuBE,mGACwD,4CAAK,yBAAG,IAAI,CAAC,uDAAR,MAAL,CADxD,KAvBF,cA0BE,0CAAG,kDACG,oBAAC,UAAD,EAAY,IAAI,CAAC,4CAAjB,EADH,qDACoG,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EADpG,oBAC6H,oBAAC,UAAD,EAAY,IAAI,CAAC,cAAjB,EAD7H,sDACkM,oBAAC,UAAD,EAAY,IAAI,CAAC,4BAAjB,EADlM,sEACqS,oBAAC,UAAD,EAAY,IAAI,CAAC,qBAAjB,EADrS,gCAEH,oBAAC,SAAD,EAAW,IAAI,CAAC,+GAAhB,EAFG,CAAH,CA1BF,cA8BE,oDACuB,IADvB,sNA9BF,cAkCE,8CAlCF,cAqCE,wXArCF,cAwCE,kaAxCF,cA2CE,oBAAC,SAAD,EAAW,IAAI,CAAC,8DAAhB,EA3CF,cA4CE,oBAAC,SAAD,EAAW,IAAI,CAAC,gEAAhB,EA5CF,cA6CE,oBAAC,SAAD,EAAW,IAAI,CAAC,oEAAhB,EA7CF,cA8CE,iKA9CF,cAkDE,mFAlDF,cAqDE,0CACE,yBAAG,IAAI,CAAC,kCAAR,iBADF,qNArDF,cAwDE,gPACqM,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EADrM,yJACoW,mCADpW,4BAC2X,mCAD3X,+EAxDF,cA2DE,2JACgH,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EADhH,yCAC+J,oBAAC,UAAD,EAAY,IAAI,CAAC,SAAjB,EAD/J,qFAC+P,oBAAC,UAAD,EAAY,IAAI,CAAC,SAAjB,EAD/P,6KA3DF,cA8DE,oBAAC,SAAD,EAAW,IAAI,CAAC,8DAAhB,EA9DF,cA+DE,oBAAC,SAAD,EAAW,IAAI,CAAC,gEAAhB,EA/DF,cAgEE,oBAAC,SAAD,EAAW,IAAI,CAAC,uEAAhB,EAhEF,cAiEE,oBAAC,SAAD,EAAW,IAAI,CAAC,2GAAhB,EAjEF,cAkEE,oBAAC,SAAD,EAAW,IAAI,CAAC,gDAAhB,EAlEF,cAmEE,qGAC0D,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EAD1D,qFACqJ,mDADrJ,qRACob,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EADpb,mBAC6c,oBAAC,UAAD,EAAY,IAAI,CAAC,SAAjB,EAD7c,mBAC2e,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EAD3e,uCACwhB,oBAAC,UAAD,EAAY,IAAI,CAAC,cAAjB,EADxhB,4GAnEF,cAuEE,0CAvEF,cA0EE,wOA1EF,CADF,CAgFH,CAED,cAAeA,CAAAA,IAAf","sourcesContent":["import React from 'react';\nimport 'katex/dist/katex.min.css';\nimport { InlineMath, BlockMath } from 'react-katex';\n\n/*\n        <h3>\n          Private Aggregation of Teacher Ensembles\n        </h3>\n        <p>\n          Private Aggregation of Teacher Ensembles or PATE is an alternative method to DPSGD for conducting differentially private learning. The key idea is to, rather than train a single strong model which captures a complex criterion in a differentially private manner, train a set of weaker, non-private models on partitions of the data and then perform a noisy aggregation of their predictions. Overall the method has been shown to be quite effective at the expense of some assumptions about the training procedure. There has even been an application of this technique to GANs via PATE-GAN.\n        </p>\n\n        <h3>\n          Differentially Private Federated Learning\n        </h3>\n\n        <h3>\n          Proper Development\n        </h3>\n        <p>\n          There are a number of common gotchas involved with the proper development and deployment of differentially private deep learning models.\n        </p>\n        <p>\n          The biggest is hyperparameter search and model selection. You might think intuitively that, as long as you implement and execute something like DP-SGD, you can sleep soundly at night knowing your model is privacy preserving. Although, typically many models are trained in the process of during the hyperparameter . Although in theory, the hyperparameters you{\"\\'\"}re selecting are technically data-inspired, and hence indirectly leak information. Frankly this detail is swept under the rug in research contexts. But in industry, this absolutely needs to be taken into consideration, or at the very least consciously acknowledged as a risk.\n        </p>\n        <p>\n          The second is proper evaluation. It does not suffice to simply train a single model and report its accuracy. Recall that\n        </p>\n*/\n\n\nfunction Post() {\n    return (\n      <>\n        <h2>\n          A Guide to Differentially Private Deep Learning\n        </h2>\n        <p>\n          In this post we tackle the topic of privacy-preserving deep learning. This commentary will be less so concerned with precision and proof, and moreso geared towards convincing a deep learning practitioner what privacy should mean, why its important, and how it can be achieved.\n        </p>\n\n        <h3>\n          Differential Privacy\n        </h3>\n        <p>\n          Before talking about anything else, we need to define what privacy is. There{\"\\'\"}s a near infinite continuum of what privacy <em>could</em> mean, and naturally some definitions are less vacuous than others.\n        </p>\n        <p>\n          One such definition is <em>differential privacy</em>. Differential privacy is concerned with <em>algorithms</em>, namely functions responsible for mapping a given dataset to some output space, e.g., linear regression mapping a dataset to its coefficients <InlineMath math=\"w\" /> and <InlineMath math=\"b\" />.\n        </p>\n        <p>\n          On a high level, such an algorithm would \"preserve privacy\" under the notion of differential privacy if it were to behave (approximately) the same regardless of whether you removed any individual point from the dataset. If you could achieve this property, then you <em>should</em> be convinced that this algorithm is privacy-preserving.\n        </p>\n        <p>\n          Why? Well, let{\"\\'\"}s consider how you would feel if one of these points actually corresponded to you. By the definition put forth, you wouldn{\"\\'\"}t have grounds to care whether your data is given to the algorithm - the outcome will be the same regardless. In other words, <em>you should feel like this algorithm preserves your privacy because its outputs look the same whether or not your data is given to it</em>. This is the core idea.\n        </p>\n        <p>\n          Formally, we can express this notion via the following<sup><a href=\"https://stephentu.github.io/writeups/6885-lec20-b.pdf\">1</a></sup>:\n        </p>\n        <p><em>\n          Let <InlineMath math=\"A : \\mathcal{D} \\rightarrow \\mathcal{Y}\" /> be a randomized algorithm. We call <InlineMath math=\"A\" /> \"<InlineMath math=\"\\varepsilon\" />-differentially private\" if for all <InlineMath math=\"D_1, D_2 \\in \\mathcal{D}\" /> differing in exactly one entry, and for all outputs <InlineMath math=\"y \\in \\mathcal{Y}\" />, we have that:\n        <BlockMath math=\"e^{-\\varepsilon} \\leq \\frac{\\Pr[\\mathcal{A(D_1) = y}]}{\\Pr[\\mathcal{A(D_2) = y}]} \\leq e^\\varepsilon\" />\n        </em></p>\n        <p>\n          Upon inspection, you{\"\\'\"}ll notice that this is saying exactly what we established earlier. Namely, the probability of a particular outcome occuring is about the same whether or not you include any particular individual in the dataset.\n        </p>\n\n        <h3>\n          Deep Learning\n        </h3>\n        <p>\n          It goes without saying that deep learning has become an extremely popular form of statistical analysis. And conveniently, the algorithms of concern in the context of deep learning align perfect with the interface prescribed by differential privacy, namely in mapping provided datasets to some output space, in this context the model parameters.\n        </p>\n        <p>\n          One of the most pervasive approaches to this is the process of stochastic gradient descent. When conducting stochastic gradient descent, we iteratively update the parameters of a model by repeatedly sampling data and taking small steps over the parameters in the direction which minimizes our loss function. In other words, we repeatedly follow something resembling the following steps:\n        </p>\n        <BlockMath math=\"\\{ x^{(1)}, x^{(1)}, \\ldots x^{(b)} \\} \\sim sample(X, b)\" />\n        <BlockMath math=\"\\ell(\\theta) = \\frac{1}{b} \\sum_i \\ell(x^{(i)} ; \\theta)\" />\n        <BlockMath math=\"\\theta \\leftarrow \\theta - \\eta \\nabla_\\theta \\ell(\\theta)\" />\n        <p>\n          It then begs the question as to how one would have to augment this procedure to achieve differential privacy, if at all possible.\n        </p>\n\n        <h3>\n          Differentially Private Stochastic Gradient Descent\n        </h3>\n        <p>\n          <a href=\"https://arxiv.org/abs/1607.00133\">Abadi et al.</a> detail the differentially private stochastic gradient descent (DP-SGD) algorithm to make traditional SGD yield a differential privacy guarantee. To describe it, we need to introduce a number of augmentations.\n        </p>\n        <p>\n          First, we have to augment our typical method for sampling. In the context of non-private deep learning, sampling is often achieved by shuffling the dataset and running through partitions of size <InlineMath math=\"b\" /> such that each example is viewed by the model exactly once per epoch. Although in the context of DP-SGD, we must opt for either Poisson<sup>2</sup> or uniform<sup>3</sup> subsampling if we want to retain an actual differential privacy guarantee.\n        </p>\n        <p>\n          Second, we need to augment the gradient calculatoin. In particular, we need to introduce a clipping parameter <InlineMath math=\"C\" />, an upper bound on the <InlineMath math=\"\\ell_2\" />-norm of each per-example gradient, as well as the noise multiplier <InlineMath math=\"\\sigma\" />, which scales the variance of the Gaussian noise applied to each gradient update after clipping. All of this together, we execute the following augmented training loop:\n        </p>\n        <BlockMath math=\"\\{ x^{(1)}, x^{(1)}, \\ldots x^{(b)} \\} \\sim sample(X, b)\" />\n        <BlockMath math=\"g^{(i)} \\leftarrow \\nabla_{\\theta} \\ell(x^{(i)} ; \\theta)\" />\n        <BlockMath math=\"\\bar{g}^{(i)} \\leftarrow g^{(i)} / \\max\\{ 1, ||g^{(i)}||_2 / C\\}\" />\n        <BlockMath math=\"\\tilde{g} \\leftarrow \\frac{1}{b} (\\sum_i \\bar{g}^{(i)} + \\sigma \\cdot C \\cdot \\mathcal{N}(0, I))\" />\n        <BlockMath math=\"\\theta \\leftarrow \\theta - \\eta \\tilde{g}\" />\n        <p>\n          In order to calculate the privacy loss corresponding to <InlineMath math=\"t\" /> executions of the above update rule, Abadi et al. also details the <em>moments accountant</em>, a specialized analysis capable of reporting the privacy loss over time. A full deep dive into tools used in the moments accountant is beyond the scope of this post, but it can be understood as simply a black box which takes in your training loop parameters (<InlineMath math=\"C\" />, <InlineMath math=\"\\sigma\" />, <InlineMath math=\"t\" />, etc.) and gives you <InlineMath math=\"\\varepsilon\" />. If interested in learning more, there exists a corresponding implementation within Tensorflow Privacy.\n        </p>\n\n        <h3>\n          Conlusion\n        </h3>\n        <p>\n          Hopefully this was a useful tutorial outlining differential privacy and its applications to deep learning in plain English. If you have any questions or have caught any errors, feel free to reach out!\n        </p>\n      </>\n    );\n}\n\nexport default Post;\n"]},"metadata":{},"sourceType":"module"}