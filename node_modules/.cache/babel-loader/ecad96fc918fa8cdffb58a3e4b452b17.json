{"ast":null,"code":"import React from'react';import'katex/dist/katex.min.css';import{InlineMath,BlockMath}from'react-katex';function Post(){return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"h2\",null,\"A Guide to Differentially Private Deep Learning\"),/*#__PURE__*/React.createElement(\"p\",null,\"In this post we review differential privacy, the task of deep learning, what privacy means in this context, and reference current results in this area.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Differential Privacy\"),/*#__PURE__*/React.createElement(\"p\",null,\"Finding a definition which fully satisfies one\\u2019s intuitive understanding of privacy is surprisingly tricky. One such definition is \",/*#__PURE__*/React.createElement(\"em\",null,\"differential privacy\"),\". On a high level, the idea behind differential privacy is that given a randomized algorithm which performs some statistical task on subsets of a dataset, such an algorithm would \\u201Cpreserve privacy\\u201D if it behaved approximately the same regardless of the inclusion or exclusion of any individual in the subset it was acting on. That is, the data of each entry would be thought to be hidden since the behavior of the algorithm closely resembles every possible case where the entry would not have been included.\"),/*#__PURE__*/React.createElement(\"p\",null,\"Formally, this is expressed as the following\",/*#__PURE__*/React.createElement(\"sup\",null,/*#__PURE__*/React.createElement(\"a\",{href:\"https://stephentu.github.io/writeups/6885-lec20-b.pdf\"},\"1\")),\":\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Deep Learning\"),/*#__PURE__*/React.createElement(\"p\",null,\"Deep learning is currently one of the most predominant forms of statistical analysis used today and has been shown to be remarkably effective for a variety of tasks. Deep neural networks, in their standard form, define a function composed of a sequence of layers where each layer represents an operation to be performed on the output of the previous layer. Typically the goal associated with such models is to find the set of parameters which map a set of inputs to a set of outputs in a way which minimizes some function, referred to as the loss function.\"),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\{ x^{(1)}, x^{(1)}, \\\\ldots x^{(b)} \\\\} \\\\sim sample(X, b)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\ell(\\\\theta) = \\\\frac{1}{b} \\\\sum_i \\\\ell(x^{(i)} ; \\\\theta)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\theta \\\\leftarrow \\\\theta - \\\\eta \\\\nabla_\\\\theta \\\\ell(\\\\theta)\"}),/*#__PURE__*/React.createElement(\"p\",null,\"A popular method for finding such parameters is via a process of stochastic gradient descent. When conducting stochastic gradient descent, one iteratively updates the parameters of the model by sampling an individual input-output pair from the dataset and partially applying their values to the error function so that the gradient of the error with respect to the parameters of the model can be computed. Then, one would update the parameters of the model in the direction opposite of the gradient, in turn minimizing the error function with respect to that example. Formally, if we let \\u03B80 be the randomly initialized parameters of the model, \\u03B8t be the parameters of the model at iteration t, (xt, yt) be our sampled input-output pair, L be our error function, and \\u03B7t be the learning rate, we iteratively apply the following update rule:\"),/*#__PURE__*/React.createElement(\"p\",null,\"Although, it\\u2019s more common in practice to opt for minibatch gradient descent. Rather than calculating gradients with respect to individual examples, one uniformly samples a subset of B examples without replacement, calculates the gradient with respect to each example, and applies the average of the gradients to the model. This corresponds to the following update rule:\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Differentially Private Stochastic Gradient Descent\"),/*#__PURE__*/React.createElement(\"p\",null,/*#__PURE__*/React.createElement(\"a\",{href:\"https://arxiv.org/abs/1607.00133\"},\"Abadi et al.\"),\" detail the differentially private stochastic gradient descent (DP-SGD) algorithm to make traditional SGD yield a differential privacy guarantee. To describe it, we need to introduce a number of augmentations.\"),/*#__PURE__*/React.createElement(\"p\",null,\"First, we have to augment our typical method for sampling examples from the dataset. In the context of non-private deep learning, sampling is often achieved by shuffling the dataset and running through partitions of size \",/*#__PURE__*/React.createElement(InlineMath,{math:\"b\"}),\" such that each example is viewed by the model exactly once per epoch. In the context of DP-SGD, we have to opt for either Poisson\",/*#__PURE__*/React.createElement(\"sup\",null,\"2\"),\" or uniform\",/*#__PURE__*/React.createElement(\"sup\",null,\"3\"),\" subsampling if we want a differential privacy guarantee.\"),/*#__PURE__*/React.createElement(\"p\",null,\"Second, we need to introduce a number of additional training parameters. In particular, we need to introduce a clipping parameter \",/*#__PURE__*/React.createElement(InlineMath,{math:\"C\"}),\", an upper bound on the \",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\ell_2\"}),\"-norm of each per-example gradient, as well as the noise multiplier \",/*#__PURE__*/React.createElement(InlineMath,{math:\"\\\\sigma\"}),\", which acts as the ratio between the clipping parameter and variance of the Gaussian noise applied to each gradient update after clipping.\"),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\{ x^{(1)}, x^{(1)}, \\\\ldots x^{(b)} \\\\} \\\\sim sample(X, b)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"g^{(i)} \\\\leftarrow \\\\nabla_{\\\\theta} \\\\ell(x^{(i)} ; \\\\theta)\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\bar{g}^{(i)} \\\\leftarrow g^{(i)} / \\\\max\\\\{ 1, ||g^{(i)}||_2 / C\\\\}\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\tilde{g} \\\\leftarrow \\\\frac{1}{b} (\\\\sum_i \\\\bar{g}^{(i)} + \\\\sigma C \\\\mathcal{N}(0, I))\"}),/*#__PURE__*/React.createElement(BlockMath,{math:\"\\\\theta \\\\leftarrow \\\\theta - \\\\eta \\\\tilde{g}\"}),/*#__PURE__*/React.createElement(\"p\",null,\"In order to calculate the privacy loss corresponding to k executions of the above update rule, Abadi et al. detail the moments accountant as a method to report privacy loss over time. A full deep dive into the foundations backing the moments accountant are likely outside the scope of this post, but on a high level it can be thought of as a black box which takes in values which characterize your training loop (sampling probabilities, number of minibatches, delta, etc.) and outputs epsilon. But importantly, their method yields much tighter bounds on the privacy loss achieved than what is reported via the strong composition theorem. If interested in learning more, the algorithm was originally introduced in Abadi et al. and has a corresponding implementation within Tensorflow Privacy.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Private Aggregation of Teacher Ensembles\"),/*#__PURE__*/React.createElement(\"p\",null,\"Private Aggregation of Teacher Ensembles or PATE is an alternative method to DPSGD for conducting differentially private learning. The key idea is to, rather than train a single strong model which captures a complex criterion in a differentially private manner, train a set of weaker, non-private models on partitions of the data and then perform a noisy aggregation of their predictions. Overall the method has been shown to be quite effective at the expense of some assumptions about the training procedure. There has even been an application of this technique to GANs via PATE-GAN.\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Differentially Private Federated Learning\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Proper Development\"),/*#__PURE__*/React.createElement(\"p\",null,\"There are a number of common gotchas involved with the proper development and deployment of differentially private deep learning models.\"),/*#__PURE__*/React.createElement(\"p\",null,\"The biggest is hyperparameter search and model selection. You might think intuitively that, as long as you implement and execute something like DP-SGD, you can sleep soundly at night knowing your model is privacy preserving. Although, typically many models are trained in the process of during the hyperparameter . Although in theory, the hyperparameters you\",\"\\'\",\"re selecting are technically data-inspired, and hence indirectly leak information. Frankly this detail is swept under the rug in research contexts. But in industry, this absolutely needs to be taken into consideration, or at the very least consciously acknowledged as a risk.\"),/*#__PURE__*/React.createElement(\"p\",null,\"The second is proper evaluation. It does not suffice to simply train a single model and report its accuracy. Recall that\"));}export default Post;","map":{"version":3,"sources":["/Users/chriswaites/Documents/projects/ChrisWaites.github.io/src/posts/differentially-private-deep-learning.js"],"names":["React","InlineMath","BlockMath","Post"],"mappings":"AAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAO,0BAAP,CACA,OAASC,UAAT,CAAqBC,SAArB,KAAsC,aAAtC,CAGA,QAASC,CAAAA,IAAT,EAAgB,CACZ,mBACE,qDACE,gFADF,cAIE,uLAJF,cAQE,qDARF,cAWE,qLACqI,qDADrI,ygBAXF,cAcE,yFAC8C,4CAAK,yBAAG,IAAI,CAAC,uDAAR,MAAL,CAD9C,KAdF,cAkBE,8CAlBF,cAqBE,4kBArBF,cAwBE,oBAAC,SAAD,EAAW,IAAI,CAAC,8DAAhB,EAxBF,cAyBE,oBAAC,SAAD,EAAW,IAAI,CAAC,gEAAhB,EAzBF,cA0BE,oBAAC,SAAD,EAAW,IAAI,CAAC,oEAAhB,EA1BF,cA2BE,o3BA3BF,cA8BE,uZA9BF,cAkCE,mFAlCF,cAqCE,0CACE,yBAAG,IAAI,CAAC,kCAAR,iBADF,qNArCF,cAwCE,0QAC+N,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EAD/N,mJACwX,mCADxX,4BAC+Y,mCAD/Y,6DAxCF,cA2CE,+KACoI,oBAAC,UAAD,EAAY,IAAI,CAAC,GAAjB,EADpI,yCACmL,oBAAC,UAAD,EAAY,IAAI,CAAC,SAAjB,EADnL,qFACmR,oBAAC,UAAD,EAAY,IAAI,CAAC,SAAjB,EADnR,+IA3CF,cA8CE,oBAAC,SAAD,EAAW,IAAI,CAAC,8DAAhB,EA9CF,cA+CE,oBAAC,SAAD,EAAW,IAAI,CAAC,gEAAhB,EA/CF,cAgDE,oBAAC,SAAD,EAAW,IAAI,CAAC,uEAAhB,EAhDF,cAiDE,oBAAC,SAAD,EAAW,IAAI,CAAC,6FAAhB,EAjDF,cAkDE,oBAAC,SAAD,EAAW,IAAI,CAAC,gDAAhB,EAlDF,cAmDE,uzBAnDF,cAuDE,yEAvDF,cA0DE,wmBA1DF,cA8DE,0EA9DF,cAkEE,mDAlEF,cAqEE,wKArEF,cAwEE,sYACyW,IADzW,uRAxEF,cA2EE,wJA3EF,CADF,CAiFH,CAED,cAAeA,CAAAA,IAAf","sourcesContent":["import React from 'react';\nimport 'katex/dist/katex.min.css';\nimport { InlineMath, BlockMath } from 'react-katex';\n\n\nfunction Post() {\n    return (\n      <>\n        <h2>\n          A Guide to Differentially Private Deep Learning\n        </h2>\n        <p>\n          In this post we review differential privacy, the task of deep learning, what privacy means in this context, and reference current results in this area.\n        </p>\n\n        <h3>\n          Differential Privacy\n        </h3>\n        <p>\n          Finding a definition which fully satisfies one’s intuitive understanding of privacy is surprisingly tricky. One such definition is <em>differential privacy</em>. On a high level, the idea behind differential privacy is that given a randomized algorithm which performs some statistical task on subsets of a dataset, such an algorithm would “preserve privacy” if it behaved approximately the same regardless of the inclusion or exclusion of any individual in the subset it was acting on. That is, the data of each entry would be thought to be hidden since the behavior of the algorithm closely resembles every possible case where the entry would not have been included.\n        </p>\n        <p>\n          Formally, this is expressed as the following<sup><a href=\"https://stephentu.github.io/writeups/6885-lec20-b.pdf\">1</a></sup>:\n        </p>\n\n        <h3>\n          Deep Learning\n        </h3>\n        <p>\nDeep learning is currently one of the most predominant forms of statistical analysis used today and has been shown to be remarkably effective for a variety of tasks. Deep neural networks, in their standard form, define a function composed of a sequence of layers where each layer represents an operation to be performed on the output of the previous layer. Typically the goal associated with such models is to find the set of parameters which map a set of inputs to a set of outputs in a way which minimizes some function, referred to as the loss function.\n        </p>\n        <BlockMath math=\"\\{ x^{(1)}, x^{(1)}, \\ldots x^{(b)} \\} \\sim sample(X, b)\" />\n        <BlockMath math=\"\\ell(\\theta) = \\frac{1}{b} \\sum_i \\ell(x^{(i)} ; \\theta)\" />\n        <BlockMath math=\"\\theta \\leftarrow \\theta - \\eta \\nabla_\\theta \\ell(\\theta)\" />\n        <p>\n          A popular method for finding such parameters is via a process of stochastic gradient descent. When conducting stochastic gradient descent, one iteratively updates the parameters of the model by sampling an individual input-output pair from the dataset and partially applying their values to the error function so that the gradient of the error with respect to the parameters of the model can be computed. Then, one would update the parameters of the model in the direction opposite of the gradient, in turn minimizing the error function with respect to that example. Formally, if we let θ0 be the randomly initialized parameters of the model, θt be the parameters of the model at iteration t, (xt, yt) be our sampled input-output pair, L be our error function, and ηt be the learning rate, we iteratively apply the following update rule:\n        </p>\n        <p>\n          Although, it’s more common in practice to opt for minibatch gradient descent. Rather than calculating gradients with respect to individual examples, one uniformly samples a subset of B examples without replacement, calculates the gradient with respect to each example, and applies the average of the gradients to the model. This corresponds to the following update rule:\n        </p>\n\n        <h3>\n          Differentially Private Stochastic Gradient Descent\n        </h3>\n        <p>\n          <a href=\"https://arxiv.org/abs/1607.00133\">Abadi et al.</a> detail the differentially private stochastic gradient descent (DP-SGD) algorithm to make traditional SGD yield a differential privacy guarantee. To describe it, we need to introduce a number of augmentations.\n        </p>\n        <p>\n          First, we have to augment our typical method for sampling examples from the dataset. In the context of non-private deep learning, sampling is often achieved by shuffling the dataset and running through partitions of size <InlineMath math=\"b\" /> such that each example is viewed by the model exactly once per epoch. In the context of DP-SGD, we have to opt for either Poisson<sup>2</sup> or uniform<sup>3</sup> subsampling if we want a differential privacy guarantee.\n        </p>\n        <p>\n          Second, we need to introduce a number of additional training parameters. In particular, we need to introduce a clipping parameter <InlineMath math=\"C\" />, an upper bound on the <InlineMath math=\"\\ell_2\" />-norm of each per-example gradient, as well as the noise multiplier <InlineMath math=\"\\sigma\" />, which acts as the ratio between the clipping parameter and variance of the Gaussian noise applied to each gradient update after clipping.\n        </p>\n        <BlockMath math=\"\\{ x^{(1)}, x^{(1)}, \\ldots x^{(b)} \\} \\sim sample(X, b)\" />\n        <BlockMath math=\"g^{(i)} \\leftarrow \\nabla_{\\theta} \\ell(x^{(i)} ; \\theta)\" />\n        <BlockMath math=\"\\bar{g}^{(i)} \\leftarrow g^{(i)} / \\max\\{ 1, ||g^{(i)}||_2 / C\\}\" />\n        <BlockMath math=\"\\tilde{g} \\leftarrow \\frac{1}{b} (\\sum_i \\bar{g}^{(i)} + \\sigma C \\mathcal{N}(0, I))\" />\n        <BlockMath math=\"\\theta \\leftarrow \\theta - \\eta \\tilde{g}\" />\n        <p>\n          In order to calculate the privacy loss corresponding to k executions of the above update rule, Abadi et al. detail the moments accountant as a method to report privacy loss over time. A full deep dive into the foundations backing the moments accountant are likely outside the scope of this post, but on a high level it can be thought of as a black box which takes in values which characterize your training loop (sampling probabilities, number of minibatches, delta, etc.) and outputs epsilon. But importantly, their method yields much tighter bounds on the privacy loss achieved than what is reported via the strong composition theorem. If interested in learning more, the algorithm was originally introduced in Abadi et al. and has a corresponding implementation within Tensorflow Privacy.\n        </p>\n\n        <h3>\n          Private Aggregation of Teacher Ensembles\n        </h3>\n        <p>\n          Private Aggregation of Teacher Ensembles or PATE is an alternative method to DPSGD for conducting differentially private learning. The key idea is to, rather than train a single strong model which captures a complex criterion in a differentially private manner, train a set of weaker, non-private models on partitions of the data and then perform a noisy aggregation of their predictions. Overall the method has been shown to be quite effective at the expense of some assumptions about the training procedure. There has even been an application of this technique to GANs via PATE-GAN.\n        </p>\n\n        <h3>\n          Differentially Private Federated Learning\n        </h3>\n\n        <h3>\n          Proper Development\n        </h3>\n        <p>\n          There are a number of common gotchas involved with the proper development and deployment of differentially private deep learning models.\n        </p>\n        <p>\n          The biggest is hyperparameter search and model selection. You might think intuitively that, as long as you implement and execute something like DP-SGD, you can sleep soundly at night knowing your model is privacy preserving. Although, typically many models are trained in the process of during the hyperparameter . Although in theory, the hyperparameters you{\"\\'\"}re selecting are technically data-inspired, and hence indirectly leak information. Frankly this detail is swept under the rug in research contexts. But in industry, this absolutely needs to be taken into consideration, or at the very least consciously acknowledged as a risk.\n        </p>\n        <p>\n          The second is proper evaluation. It does not suffice to simply train a single model and report its accuracy. Recall that\n        </p>\n      </>\n    );\n}\n\nexport default Post;\n"]},"metadata":{},"sourceType":"module"}